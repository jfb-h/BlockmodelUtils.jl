var documenterSearchIndex = {"docs":
[{"location":"95-reference/#reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"95-reference/#BlockmodelUtils.Blockmodel","page":"Reference","title":"BlockmodelUtils.Blockmodel","text":"Struct representing a graph's blocked adjacency matrix.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#Base.map-Tuple{Any, Blockmodel}","page":"Reference","title":"Base.map","text":"map(fun, bm::Blockmodel)\n\nMap function fun over the blocks of the Blockmodel bm and return a k by k matrix, where k is the number of groups constituting the blockmodel.\n\nExample\n\nusing Graphs, BlockmodelUtils\n\ng = erdos_renyi(20, 0.1)\ngs = rand(['a', 'b'], 20)\nbm = blockmodel(g, gs)\n\nmap(sum, bm) # number of edges in each block\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BlockmodelUtils.blockmodel-Tuple{Graphs.AbstractGraph, AbstractVector}","page":"Reference","title":"BlockmodelUtils.blockmodel","text":"blockmodel(g, groups; by=identity)\n\nCreate a Blockmodel from Graphs.AbstractGraph g and vector of group memberships groups. The function passed to by used to order the groups in the blockmodel.\n\nExample\n\nusing Graphs, BlockmodelUtils\n\ng = erdos_renyi(20, 0.1)\ngs = rand(['a', 'b'], 20)\nbm = blockmodel(g, gs)\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BlockmodelUtils.densityplot","page":"Reference","title":"BlockmodelUtils.densityplot","text":"densityplot!(ax, bm)\ndensityplot(bm)\n\nPlot the block density matrix as a heatmap.\n\nAttributes\n\nxticklabels = bm.labels\nyticklabels = bm.labels\nrotate_xlabels = false\nkwargs... are passed to Makie.heatmap\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BlockmodelUtils.densityplot!","page":"Reference","title":"BlockmodelUtils.densityplot!","text":"densityplot!(ax, bm)\ndensityplot(bm)\n\nPlot the block density matrix as a heatmap.\n\nAttributes\n\nxticklabels = bm.labels\nyticklabels = bm.labels\nrotate_xlabels = false\nkwargs... are passed to Makie.heatmap\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BlockmodelUtils.ei_index-Tuple{Graphs.AbstractGraph, AbstractVector}","page":"Reference","title":"BlockmodelUtils.ei_index","text":"ei_index(g, groups; level=:graph, mode=:both)\n\nCompute Krackhardt's EI-index (Krackhardt & Stern 1988) for graph g and vector of group affiliations groups, defined as (E - I) / (E + I) for external (between group) edges E and internal (withing group) edges I.\n\nSpecify the level at wich to compute the index by setting the respective keyword to graph, group, or node. For directed g, specify the mode as both, in, or out. For level=graph, the three modes will be the same.\n\nExample\n\nusing Graphs, BlockmodelUtils\n\ng = erdos_renyi(20, 0.1);\ngs = rand('a':'c', 20);\nei_index(g, gs; level=:group)\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BlockmodelUtils.flowerplot","page":"Reference","title":"BlockmodelUtils.flowerplot","text":"flowerplot!(ax, bm)\nflowerplot(bm)\n\nPlot the network with nodes positioned in circles according to the blockmodel groups. The first group is placed in the center.\n\nAttributes\n\nedgecolor = :grey70\nedgewidth = 1\nnodecolor = :black\nshowlabels = true\nradii = fill(1, length(bm.labels))\nargs... further arguments are passed to Makie.scatter\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BlockmodelUtils.flowerplot!","page":"Reference","title":"BlockmodelUtils.flowerplot!","text":"flowerplot!(ax, bm)\nflowerplot(bm)\n\nPlot the network with nodes positioned in circles according to the blockmodel groups. The first group is placed in the center.\n\nAttributes\n\nedgecolor = :grey70\nedgewidth = 1\nnodecolor = :black\nshowlabels = true\nradii = fill(1, length(bm.labels))\nargs... further arguments are passed to Makie.scatter\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BlockmodelUtils.permuteplot","page":"Reference","title":"BlockmodelUtils.permuteplot","text":"permuteplot!(ax, bm)\npermuteplot(bm)\n\nPlot the permuted adjacency matrix with a grid outlining the blockmodel blocks.\n\nAttributes\n\ncellcolor = :black\nlinecolor = :black\nframecolor = linecolor\nrotate_xlabels = fale\nxticklabels = bm.labels\nyticklabels = bm.labels\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BlockmodelUtils.permuteplot!","page":"Reference","title":"BlockmodelUtils.permuteplot!","text":"permuteplot!(ax, bm)\npermuteplot(bm)\n\nPlot the permuted adjacency matrix with a grid outlining the blockmodel blocks.\n\nAttributes\n\ncellcolor = :black\nlinecolor = :black\nframecolor = linecolor\nrotate_xlabels = fale\nxticklabels = bm.labels\nyticklabels = bm.labels\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#Graphs.density-Union{Tuple{Blockmodel{T, G}}, Tuple{G}, Tuple{T}} where {T<:Integer, G<:Graphs.SimpleGraphs.AbstractSimpleGraph}","page":"Reference","title":"Graphs.density","text":"density(bm::Blockmodel)\n\nCompute the blockdensity matrix for Blockmodel bm. For diagonal blocks, the diagonal is subtracted from the number of possible edges.\n\n\n\n\n\n","category":"method"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"BlockmodelUtils.jl is a Julia package to represent, analyse, and plot network blockmodels, i.e., blocked graph adjacency matrices according to some node partition. As of now, this package does not contain functionality to infer node partitions from network structure (i.e., clusters or equivalence-based partitions). Its main purpose is instead to provide a simple representation of blockmodels and some plotting utilities.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"To install this package, enter the package manager at the REPL by pressing ] and write add BlockmodelUtils.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Plotting utilities are provided by a package extension using the Makie.jl ecosystem, so to use them you will also have to install one of the Makie backends, e.g. CairoMakie.","category":"page"},{"location":"#Getting-started","page":"Introduction","title":"Getting started","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"For a graph g and a vector of group labels groups, create a blockmodel with the blockmodel function:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Graphs, BlockmodelUtils\n\n# create a random graph and node partition\nn = 20\ng = erdos_renyi(n, 0.1)\ngroups = rand('a':'d', n)\n\n# create the blockmodel\nbm = blockmodel(g, groups)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The resulting Blockmodel prints the blockdensity matrix:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Blockmodel{Int64, SimpleGraph{Int64}}\n4 groups with sizes [6, 7, 4, 3]\n┌───┬───────┬───────┬───────┬───────┐\n│   │     1 │     2 │     3 │     4 │\n├───┼───────┼───────┼───────┼───────┤\n│ a │ 0.200 │ 0.214 │ 0.250 │ 0.278 │\n├───┼───────┼───────┼───────┼───────┤\n│ b │ 0.214 │ 0.095 │ 0.179 │ 0.286 │\n├───┼───────┼───────┼───────┼───────┤\n│ c │ 0.250 │ 0.179 │ 0.167 │ 0.083 │\n├───┼───────┼───────┼───────┼───────┤\n│ d │ 0.278 │ 0.286 │ 0.083 │ 0.000 │\n└───┴───────┴───────┴───────┴───────┘","category":"page"},{"location":"#Plotting","page":"Introduction","title":"Plotting","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The package contains an extension for Makie.jl to plot blockmodels in a variety of ways. Here's an example showcasing the three available functions permuteplot, densityplot and flowerplot:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Graphs\nusing BlockmodelUtils\nusing CairoMakie\n\nn_groups, s_groups = 7, 20\ng = stochastic_block_model(5.0, 0.5, fill(s_groups, n_groups))\n\ngroups = repeat('a':'g'; inner=s_groups)\nbm = blockmodel(g, groups)\n\nfig = Figure(size=(1000, 300));\n\nax1 = Axis(fig[1,1])\nax2 = Axis(fig[1,2])\nax3 = Axis(fig[1,3])\n\npermuteplot!(ax1, bm; linecolor=:grey70, framecolor=:black)\ndensityplot!(ax2, bm; colormap=:greys)\nflowerplot!(ax3, bm; nodecolor=coalesce.(indexin(groups, 'a':'g')))\n\nfig\n\nsave(\"bmplot.png\", fig); nothing #hide","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: )","category":"page"},{"location":"#EI-Index","page":"Introduction","title":"EI-Index","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"A simple and useful metric for assessing the degree to which a set of edges in a network tends to within- or between-group linkage is the EI-Index introduced by Krackhardt & Stern (1988). It is defined as fracE-IE+I where E is the number of external (i.e., between-group) edges and I is the number of internal (i.e., within-group) edges. It can be computed as a graph-level, group-level, or node-level index:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Graphs, BlockmodelUtils #hide\ng = erdos_renyi(50, 200)\ngs = rand('a':'d', 50)\nei_index(g, gs; level=:group)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"For directed networks, you can specify how to treat edge directions via the mode keyword.","category":"page"}]
}
